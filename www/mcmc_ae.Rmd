---
title: "Statistical model of active echo imaging"
author: "W. Bauer"
date: "04/16/2015"
output: html_document
---

The Universal UR5 robot arm advertises 0.1 mm repeatability. Assume this value represents standard deviation in quantities which depend on the arm's position.

The first step in calibration is, for each of 28 poses, to estimate the position of the active echo (AE) in the image frame, i.e., the coordinate frame of the transducer array. Our interest here is a statistical model for AE position estimation for a single pose.

The pose is first adjusted so that the AE is in the midplane of the image frame, i.e., so that its y coordinate, $p_y,$ is nominally zero. Distances, $r_1,\:r_2,\ldots,\:r_N$ between the AE and the $N$ transducer elements are measured via time of flight. Since all of these measurements depend on position of the robot arm, they are subject to errors which we will model as normally distributed with mean zero and standard deviation 0.1 mm.

Given a putative position, $p = (p_z, p_x, p_y),$ of the AE in the image frame, let $d_1(p)\:,\ldots,\:d_N(p)$ be the computed distances between the $N$ transducer elements. I.e., if $t_{i,x}$ represents the x coordinate of the $i^{th}$ transducer, then$$d_i(p) = \sqrt{p_z^2 + (p_x-t_{i,x})^2 + p_y^2}\:\:i=1,\:\ldots\:,N.$$The corresponding conditional likehood of the measurements given $p$ is thus,$$P(r_1,\:\ldots\:,r_N | p) = (2\pi\sigma^2)^{-N/2}e^{-\sum_{i=1}^N(r_i-d_i(p))^2/2\sigma^2},$$where $\sigma=0.1.$

Assume that the AE will be positioned approximately within a small region of the midplane, such that any $p_x$ and $p_z$ in that region would be equally likely. Then, for $p_x$ and $p_z$ within the region,$$P(p) = \frac{1}{A}(2\pi\sigma^2)^{-1/2}e^{-p_y^2/2\sigma^2},$$where $A$ is the region's area. The total probability of a putative $p$ and the observed measurments is,$$P(r_1,\:\ldots\:,r_N | p)P(p) = \frac{1}{A}(2\pi\sigma^2)^{-(N+1)/2}e^{-p_y^2/2\sigma^2-\sum_{i=1}^N(r_i-d_i(p))^2/2\sigma^2}\:\:\left(equ. 1\right)$$

A maximum likelihood method would would find a single point, $p^*,$ at which *equation 1* attains its maximum value. To do so, it would suffice to minimize the expression,$$p_y^2 + \sum_{i=1}^N(r_i-d_i(p))^2,$$which appears in the exponent, but which does not depend on $\sigma,$ the parameter which quantifies error. In contrast, a Bayesian method would attempt to determine the posterior distribution of $p$ given the observations, $r_1,\:\ldots\:,r_N,$ $$P(p | r_1,\:\ldots\:,r_N) = \frac{P(r_1,\:\ldots\:,r_N | p)P(p)}{P(r_1,\:\ldots\:,r_N)}\:\:\left(equ. 2\right),$$hence to include quantification of error.

The denominator in equation 2 is a constant, but very difficult to determine in closed form since it is the integral of the numerator with respect to $p$. It is easy to compute the posterior only up to a constant of proportionality,$$P(p | r_1,\:\ldots\:,r_N) \propto e^{-p_y^2/2\sigma^2-\sum_{i=1}^N(r_i-d_i(p))^2/2\sigma^2}\:\:\left(equ. 3\right)$$Thus, we can easily compute the only the *ratio* of the posterior probabilities of any two values of $p.$ Such ratios, however, can be used to generate samples with the correct relative frequencies, thus to simulate draws from the posterior distribution.

To create data for experimentation, suppose we have a 128 element transducer array with elements spaced at 0.25 mm intervals. Thus $t_{i, x} = 0.25i,\:\:i=1,\:\ldots\:,128.$ (Transducer z and y coordinates would be zero in the image frame.) Suppose the AE is crudely estimated to be somewhere in a 10 mm by 10 mm square centered at $x = 16 mm,\:z=20mm.$ We generate a random point, `p_actual`, with x and z coordinates in this square, and a y coordinate representing midplane error.

```{r}
set.seed(1429305885) # System time when the line was written.
p_actual <- c(runif(1, 11, 21), runif(1, 15, 25), rnorm(1, mean=0, sd=0.1))
p_actual
```

Distances between points and transducers must be computed frequently, so we write a function for the purpose.

```{r}
getDistances <- function(p){
  if(!is.numeric(p[1]))print(p)
  sapply(0.25*(1:128), function(tx)sqrt(p[1]^2 + (p[2]-tx)^2 + p[3]^2))
}
```

We'll apply this function to `p_actual` and add errors to form $r = (r_1,\:\ldots\:,r_128).$

```{r}
r <- getDistances(p_actual) + rnorm(128, mean=0, sd=0.1)
```

Because the exponentiation on right side of *equation 3* can challenge precision, we'll write a function to compute the exponent itself, i.e., the natural log of the right side. We assume the argument, `p`, is within the specified square. 

```{r}
q <- function(p, r, sigma){
  d <- getDistances(p)
  -(p[3]^2 + sum((r-d)^2))/(2*sigma^2)
  }
```

